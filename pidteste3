/* * PROJETO: PID TANQUE - BAREMETAL TOTAL
 * ATmega328P - 16MHz
 */

// --- MACROS DE REGISTRADORES ---
#define REG8(x)  (*(volatile unsigned char *)(x))
#define REG16(x) (*(volatile unsigned int *)(x))

// GPIO
#define _DDRD   REG8(0x2A)
#define _PORTD  REG8(0x2B)
#define _DDRB   REG8(0x24)
#define _PORTB  REG8(0x25)
#define _SREG   REG8(0x5F)

// Interrupção Externa (INT0)
#define _EICRA  REG8(0x69)
#define _EIMSK  REG8(0x3D)

// Timer1 (Controle do Servo no Pino 9)
#define _TCCR1A REG8(0x80)
#define _TCCR1B REG8(0x81)
#define _ICR1   REG16(0x86)
#define _OCR1A  REG16(0x88)

// UART (Comunicação com ESP32/PC)
#define _UCSR0A REG8(0xC0)
#define _UCSR0B REG8(0xC1)
#define _UCSR0C REG8(0xC2)
#define _UBRR0  REG16(0xC4)
#define _UDR0   REG8(0xC6)

// --- CONSTANTES DO SERVO CONTÍNUO ---
#define us_to_ticks(s) ((s)*2) // 16MHz / Prescaler 8 = 2 ticks por us
#define SERVO_STOP      us_to_ticks(1500) // 1.5ms (Parado)
#define SERVO_MAX_DIR   us_to_ticks(2000) // 2.0ms (Giro forte p/ direita)
#define SERVO_MAX_ESQ   us_to_ticks(1000) // 1.0ms (Giro forte p/ esquerda)

// --- VARIÁVEIS GLOBAIS ---
volatile unsigned long pulseCount = 0;
float setpoint = 15.0; // Vazão alvo em L/min
float Kp = 1.2, Ki = 0.05, Kd = 0.1; // Parâmetros PID
float erro_anterior = 0, integral = 0;

// --- FUNÇÕES DE COMUNICAÇÃO ---

void uart_init() {
    _UBRR0 = 103; // Configura 9600 baud para 16MHz
    _UCSR0B = (1 << 3); // Habilita Transmissão (TX)
    _UCSR0C = (1 << 2) | (1 << 1); // Modo 8 bits
}

void uart_send_char(char c) {
    while (!(_UCSR0A & (1 << 5))); // Espera buffer vazio
    _UDR0 = c;
}

void uart_send_msg(const char* s) {
    while (*s) uart_send_char(*s++);
}

// Delay manual sem timers para não conflitar com o PWM
void delay_manual(unsigned long ciclos) {
    for (volatile unsigned long i = 0; i < ciclos; i++);
}

// --- VETOR DE INTERRUPÇÃO (INT0 - Sensor de Vazão) ---
extern "C" void __vector_1 (void) __attribute__ ((signal, used, externally_visible));
void __vector_1 (void) {
    pulseCount++;
}

// --- LÓGICA DE MOVIMENTO "BURST" ---

void burst_servo(int direcao) {
    if (direcao == 1) {
        _OCR1A = SERVO_MAX_DIR;
    } else {
        _OCR1A = SERVO_MAX_ESQ;
    }

    // O servo se move por 20ms (1 ciclo completo de PWM)
    // Isso garante o "movimento curto e forte" que você pediu
    delay_manual(40000); 

    // Para o servo imediatamente
    _OCR1A = SERVO_STOP;
}

// --- CONFIGURAÇÃO E MAIN ---

int main(void) {
    // 1. Configurar Servo (Pino 9 - PB1)
    _DDRB |= (1 << 1); 
    _TCCR1A = (1 << 7) | (1 << 1); // Modo Fast PWM, Clear OC1A on Compare
    _TCCR1B = (1 << 4) | (1 << 3) | (1 << 1); // Prescaler 8
    _ICR1 = us_to_ticks(20000); // 20ms período
    _OCR1A = SERVO_STOP;

    // 2. Configurar Sensor de Vazão (Pino 2 - PD2)
    _DDRD &= ~(1 << 2);
    _PORTD |= (1 << 2); // Pull-up interno
    _EICRA = (1 << 1) | (1 << 0); // Borda de subida
    _EIMSK = (1 << 0); // Habilita INT0

    uart_init();
    _SREG |= (1 << 7); // Ativa interrupções globais (sei)

    uart_send_msg("Iniciando Sistema de Tanque Baremetal...\r\n");

    while (1) {
        // 3. ESPERA 1 SEGUNDO (Tempo de amostragem longo)
        delay_manual(2000000);

        // 4. LEITURA DA VAZÃO (Seção Crítica)
        _SREG &= ~(1 << 7); // cli
        unsigned long pulsos = pulseCount;
        pulseCount = 0;
        _SREG |= (1 << 7); // sei

        // Converte pulsos para vazão (Exemplo genérico: Pulsos/7.5)
        float vazao_atual = (float)pulsos / 7.5;

        // 5. CÁLCULO DO PID
        float erro = setpoint - vazao_atual;
        integral += erro;
        
        // Anti-windup: Limita a integral para o servo não ficar "preso"
        if (integral > 30) integral = 30;
        if (integral < -30) integral = -30;

        float derivativa = erro - erro_anterior;
        float PID_saida = (Kp * erro) + (Ki * integral) + (Kd * derivativa);
        erro_anterior = erro;

        // 6. ATUAÇÃO DISCRETA (O "BURST")
        // Se o PID calcular uma necessidade de correção maior que a margem (1.0)
        if (PID_saida > 1.0) {
            burst_servo(1); // Dá um tranco para abrir
        } 
        else if (PID_saida < -1.0) {
            burst_servo(-1); // Dá um tranco para fechar
        }

        // 7. TELEMETRIA (Para o ESP32 receber e mandar pro Blynk)
        uart_send_msg("V:"); 
        // Aqui você pode adicionar sua função ftoa para ver os valores reais
        uart_send_msg("OK\r\n");
    }

    return 0;
}
