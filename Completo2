/**
 * PROJETO FINAL: Controle de Tanque Baremetal - André
 * FUSÃO: PID + Bomba/Ultrassom + LCD/Encoder + Telemetria ESP32
 * DATA: 11/12
 */

#define REG8(x)  (*(volatile unsigned char *)(x))
#define REG16(x) (*(volatile unsigned int *)(x))

// --- REGISTRADORES MANUAIS ---
#define _PIND   REG8(0x29)
#define _DDRD   REG8(0x2A)
#define _PORTD  REG8(0x2B)
#define _PINB   REG8(0x23)
#define _DDRB   REG8(0x24)
#define _PORTB  REG8(0x25)
#define _SREG   REG8(0x5F)
#define _EICRA  REG8(0x69)
#define _EIMSK  REG8(0x3D)

// Timer1 (Servo no Pino 9)
#define _TCCR1A REG8(0x80)
#define _TCCR1B REG8(0x81)
#define _ICR1   REG16(0x86)
#define _OCR1A  REG16(0x88)

// I2C (LCD)
#define _TWBR   REG8(0xB8)
#define _TWSR   REG8(0xB9)
#define _TWDR   REG8(0xBB)
#define _TWCR   REG8(0xBC)

// UART (Comunicação 9600 baud)
#define _UDR0   REG8(0xC6)
#define _UCSR0A REG8(0xC0)
#define _UCSR0B REG8(0xC1)
#define _UCSR0C REG8(0xC2)
#define _UBRR0L REG8(0xC4)

// --- CONSTANTES SERVO ---
#define SERVO_STOP 3000 // 1.5ms
#define SERVO_DIR  4000 // 2.0ms
#define SERVO_ESQ  2000 // 1.0ms

// --- VARIÁVEIS GLOBAIS ---
volatile float Kp = 1.0, Ki = 0.1, Kd = 0.01;
volatile float setpoint = 15.0, vazao_atual = 0, erro = 0, nivel = 0;
float erro_anterior = 0, integral = 0;
float kpe = 0, kii = 0, kdd = 0; // Termos individuais para o Blynk

unsigned char param_sel = 0; 
volatile unsigned long pulseCount = 0;
unsigned char c_on = 0, c_off = 0;

// --- FUNÇÕES DE APOIO ---

void delay_us(unsigned int us) {
    while(us--) { __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); }
}

void delay_ms(unsigned int ms) {
    while(ms--) { for(unsigned long i = 0; i < 1600; i++) __asm__ __volatile__ ("nop"); }
}

// UART: Enviar Float como Texto (Manual)
void uart_putc(char c) { while (!(_UCSR0A & (1 << 5))); _UDR0 = c; }
void uart_puts(const char* s) { while (*s) uart_putc(*s++); }

void uart_send_float(float f) {
    if (f < 0) { uart_putc('-'); f = -f; }
    int ip = (int)f;
    int dp = (int)((f - ip) * 100);
    char buf[10]; int i = 0;
    if (ip == 0) uart_putc('0');
    while (ip > 0) { buf[i++] = (ip % 10) + '0'; ip /= 10; }
    while (i > 0) uart_putc(buf[--i]);
    uart_putc('.');
    if (dp < 0) dp = -dp;
    if (dp < 10) uart_putc('0');
    i = 0; if (dp == 0) uart_putc('0');
    while (dp > 0) { buf[i++] = (dp % 10) + '0'; dp /= 10; }
    while (i > 0) uart_putc(buf[--i]);
}

// ISR do Sensor de Vazão (Pino 2)
extern "C" void __vector_1 (void) __attribute__ ((signal, used, externally_visible));
void __vector_1 (void) { pulseCount++; }

// --- ATUAÇÃO ---

void burst_servo(int dir) {
    _OCR1A = (dir == 1) ? SERVO_DIR : SERVO_ESQ;
    delay_ms(25); // Pulso rápido e forte
    _OCR1A = SERVO_STOP;
}

unsigned int medir_nivel() {
    _PORTD |= (1 << 7); delay_us(10); _PORTD &= ~(1 << 7);
    while(!(_PIND & (1 << 6)));
    unsigned int t = 0; 
    while((_PIND & (1 << 6)) && (t < 15000)) { t++; delay_us(1); }
    return t; // Retorna ticks (proporcional à distância)
}

// --- TELEMETRIA E COMANDOS ---

void enviar_dados_esp32() {
    // Envia no formato: vazao,nivel,erro,kpe,kii,kdd\n
    uart_send_float(vazao_atual); uart_putc(',');
    uart_send_float(nivel);       uart_putc(',');
    uart_send_float(erro);        uart_putc(',');
    uart_send_float(kpe);         uart_putc(',');
    uart_send_float(kii);         uart_putc(',');
    uart_send_float(kdd);         uart_putc('\n');
}

void verificar_comandos_esp32() {
    if (_UCSR0A & (1 << 7)) { // Se recebeu algo (RXC0)
        char cmd = _UDR0;
        // O código do ESP envia "P", "I" ou "D" seguido do valor
        // Para baremetal simplificado, vamos apenas sinalizar a recepção
        // (Em um sistema real você usaria atof() aqui)
    }
}

// --- MAIN ---

int main(void) {
    // Config Pinos: 9(Servo), 13(Bomba), 7(Trigger) = Saídas
    _DDRB |= (1 << 1) | (1 << 5); _PORTB |= (1 << 5); 
    _DDRD |= (1 << 7);
    _DDRD &= ~((1 << 2)|(1 << 3)|(1 << 4)|(1 << 5)|(1 << 6));
    _PORTD |= (1 << 2)|(1 << 3)|(1 << 4)|(1 << 5); // Pull-ups

    // Timer1 Servo
    _TCCR1A = (1 << 7) | (1 << 1); _TCCR1B = (1 << 4) | (1 << 3) | (1 << 1); 
    _ICR1 = 40000; _OCR1A = SERVO_STOP;

    // UART 9600
    _UBRR0L = 103; _UCSR0B = (1 << 3) | (1 << 4); _UCSR0C = (3 << 1);

    // I2C/LCD (Init omitido mas deve estar aqui)
    _TWBR = 72; _TWSR = 0x00;

    // Interrupção Vazão
    _EICRA = (1 << 1) | (1 << 0); _EIMSK = (1 << 0);
    _SREG |= (1 << 7); 

    unsigned long timer_geral = 0;
    unsigned char l_clk = (_PIND & (1 << 3));

    while(1) {
        timer_geral++;

        // 1. ENCODER (Sempre checando)
        unsigned char clk = (_PIND & (1 << 3));
        if (clk != l_clk && clk == 0) {
            if ((_PIND & (1 << 4)) != clk) {
                if (param_sel == 0) Kp += 0.1; else if (param_sel == 1) Ki += 0.01; else Kd += 0.01;
            } else {
                if (param_sel == 0) Kp -= 0.1; else if (param_sel == 1) Ki -= 0.01; else Kd -= 0.01;
            }
        }
        l_clk = clk;

        // 2. TAREFAS PERIÓDICAS (~1 segundo)
        if (timer_geral > 25000) { 
            // Nível e Bomba
            unsigned int d = medir_nivel();
            nivel = (float)d; // Simples atribuição para telemetria
            if (d > 850) { c_on++; c_off=0; if(c_on>=5){ _PORTB &= ~(1 << 5); c_on=0; } }
            else if (d < 700) { c_off++; c_on=0; if(c_off>=5){ _PORTB |= (1 << 5); c_off=0; } }

            // PID Vazão
            _SREG &= ~(1 << 7); vazao_atual = (float)pulseCount / 7.5; pulseCount = 0; _SREG |= (1 << 7);
            erro = setpoint - vazao_atual;
            integral += erro; if(integral > 20) integral = 20;

            kpe = Kp * erro;
            kii = Ki * integral;
            kdd = Kd * (erro - erro_anterior);
            
            float out = kpe + kii + kdd;
            erro_anterior = erro;

            if (out > 1.0) burst_servo(1); else if (out < -1.0) burst_servo(-1);

            // Comunicação com ESP32
            enviar_dados_esp32();
            verificar_comandos_esp32();

            timer_geral = 0;
        }
    }
}
