// Dentro do main, antes do while(1)
unsigned char estado_anterior_clk = (_PIND & (1 << 2));

while(1) {
    unsigned char estado_atual_clk = (_PIND & (1 << 2));

    // Detecta apenas a borda de descida (quando o CLK vai de 1 para 0)
    if (estado_anterior_clk && !estado_atual_clk) {
        delay_us(1000); // 1ms de debounce para ignorar o ruído inicial
        
        // Lê o DT agora para decidir a direção
        if ((_PIND & (1 << 3))) {
            // Sentido Horário
            if (param_sel == 0) Kp += 0.1;
            else if (param_sel == 1) Ki += 0.01;
            else Kd += 0.01;
        } else {
            // Sentido Anti-horário
            if (param_sel == 0) Kp -= 0.1;
            else if (param_sel == 1) Ki -= 0.01;
            else Kd -= 0.01;
        }

        // Limites
        if (Kp < 0) Kp = 0; if (Ki < 0) Ki = 0; if (Kd < 0) Kd = 0;
        if (Kp > 99) Kp = 99; // Evita estourar o LCD
        
        atualiza_display();
    }
    estado_anterior_clk = estado_atual_clk;

    // Lógica do Botão (SW) - Mantém a que já funciona
    unsigned char sw = (_PIND & (1 << 4));
    if (!sw && last_sw) {
        delay_ms(200); // Debounce maior para o botão
        param_sel = (param_sel + 1) % 3;
        atualiza_display();
    }
    last_sw = sw;
}
