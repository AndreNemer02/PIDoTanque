/* * PROJETO: PID TANQUE - BAREMETAL TOTAL (SEM STDINT)
 * DATA DA APRESENTAÇÃO: 11/12
 */

#define REG8(x)  (*(volatile unsigned char *)(x))
#define REG16(x) (*(volatile unsigned int *)(x))

// GPIO e Registradores de Sistema
#define _DDRD   REG8(0x2A)
#define _PORTD  REG8(0x2B)
#define _DDRB   REG8(0x24)
#define _PORTB  REG8(0x25)
#define _SREG   REG8(0x5F)

// Interrupção Externa (Pino 2)
#define _EICRA  REG8(0x69)
#define _EIMSK  REG8(0x3D)

// Timer1 (Servo no Pino 9)
#define _TCCR1A REG8(0x80)
#define _TCCR1B REG8(0x81)
#define _ICR1   REG16(0x86)
#define _OCR1A  REG16(0x88)

// UART
#define _UCSR0A REG8(0xC0)
#define _UCSR0B REG8(0xC1)
#define _UBRR0  REG16(0xC4)
#define _UDR0   REG8(0xC6)

// Configurações do Servo
#define us_to_ticks(s) ((s)*2) 
#define SERVO_STOP      us_to_ticks(1500) // Parado
#define SERVO_MAX_DIR   us_to_ticks(2000) // Giro forte Horário
#define SERVO_MAX_ESQ   us_to_ticks(1000) // Giro forte Anti-horário

// Variáveis de Controle
volatile unsigned long pulseCount = 0;
float setpoint = 15.0; 
float Kp = 1.5, Ki = 0.01, Kd = 0.1; // Parâmetros para ajuste
float erro_anterior = 0, integral = 0;

// Vetor de Interrupção INT0 (Vazão)
extern "C" void __vector_1 (void) __attribute__ ((signal, used, externally_visible));
void __vector_1 (void) {
    pulseCount++;
}

void delay_manual(unsigned long n) {
    for (volatile unsigned long i = 0; i < n; i++);
}

void burst_servo(int direcao) {
    // Escolhe a direção com base no sinal do PID
    if (direcao == 1) _OCR1A = SERVO_MAX_DIR;
    else _OCR1A = SERVO_MAX_ESQ;

    // Movimento curto de 20ms (1 ciclo de PWM) para dar o "tranco"
    delay_manual(40000); 

    // Para e mantém parado até a próxima análise
    _OCR1A = SERVO_STOP;
}

int main(void) {
    // Inicialização do Servo (Pino 9)
    _DDRB |= (1 << 1); 
    _TCCR1A = (1 << 7) | (1 << 1); 
    _TCCR1B = (1 << 4) | (1 << 3) | (1 << 1); 
    _ICR1 = us_to_ticks(20000); 
    _OCR1A = SERVO_STOP;

    // Inicialização do Sensor (Pino 2)
    _DDRD &= ~(1 << 2);
    _PORTD |= (1 << 2); 
    _EICRA = (1 << 1) | (1 << 0); 
    _EIMSK = (1 << 0);

    // Ativa Interrupções
    _SREG |= (1 << 7); 

    while (1) {
        // Espera 1 segundo para estabilizar a leitura da vazão
        delay_manual(2000000);

        // Leitura protegida dos pulsos
        _SREG &= ~(1 << 7);
        unsigned long l_pulsos = pulseCount;
        pulseCount = 0;
        _SREG |= (1 << 7);

        float vazao_atual = (float)l_pulsos / 7.5;
        float erro = setpoint - vazao_atual;

        // Cálculo PID
        integral += erro;
        if (integral > 20) integral = 20;   // Limite para evitar erro acumulado excessivo
        if (integral < -20) integral = -20;

        float derivativa = erro - erro_anterior;
        float PID_saida = (Kp * erro) + (Ki * integral) + (Kd * derivativa);
        erro_anterior = erro;

        // Ação de controle: decide direção e se deve agir
        if (PID_saida > 1.0) {
            burst_servo(1);  // Erro positivo: Abre
        } 
        else if (PID_saida < -1.0) {
            burst_servo(-1); // Erro negativo: Fecha
        }
        // Se estiver entre -1.0 e 1.0, o servo continua em SERVO_STOP (parado)
    }
    return 0;
}
