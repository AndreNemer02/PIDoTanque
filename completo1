/**
 * PROJETO FINAL BAREMETAL - ANDRÉ
 * Tanque: PID de Vazão, Bomba Ultrassônica, LCD e Encoder.
 */

#define REG8(x)  (*(volatile unsigned char *)(x))
#define REG16(x) (*(volatile unsigned int *)(x))

// --- REGISTRADORES ---
#define _PIND   REG8(0x29)
#define _DDRD   REG8(0x2A)
#define _PORTD  REG8(0x2B)
#define _PINB   REG8(0x23)
#define _DDRB   REG8(0x24)
#define _PORTB  REG8(0x25)
#define _SREG   REG8(0x5F)
#define _EICRA  REG8(0x69)
#define _EIMSK  REG8(0x3D)

// Timer1 (Servo), I2C e UART
#define _TCCR1A REG8(0x80)
#define _TCCR1B REG8(0x81)
#define _ICR1   REG16(0x86)
#define _OCR1A  REG16(0x88)
#define _TWBR   REG8(0xB8)
#define _TWSR   REG8(0xB9)
#define _TWDR   REG8(0xBB)
#define _TWCR   REG8(0xBC)
#define _UDR0   REG8(0xC6)
#define _UCSR0A REG8(0xC0)
#define _UCSR0B REG8(0xC1)
#define _UCSR0C REG8(0xC2)
#define _UBRR0L REG8(0xC4)

// --- CONSTANTES DO SERVO CONTÍNUO ---
#define SERVO_STOP  3000 // 1.5ms
#define SERVO_DIR   4000 // 2.0ms (Abre forte)
#define SERVO_ESQ   2000 // 1.0ms (Fecha forte)

// --- VARIÁVEIS GLOBAIS ---
volatile float Kp = 1.2, Ki = 0.05, Kd = 0.1;
volatile float setpoint = 15.0, vazao_atual = 0, erro = 0;
float erro_anterior = 0, integral = 0;
unsigned char param_sel = 0; 
volatile unsigned long pulseCount = 0;
unsigned char c_on = 0, c_off = 0;

// --- FUNÇÕES DE APOIO ---

void delay_us(unsigned int us) {
    while(us--) { __asm__ __volatile__ ("nop"); __asm__ __volatile__ ("nop"); }
}

void delay_ms(unsigned int ms) {
    while(ms--) { for(unsigned long i = 0; i < 1600; i++) __asm__ __volatile__ ("nop"); }
}

// ISR Sensor Vazão
extern "C" void __vector_1 (void) __attribute__ ((signal, used, externally_visible));
void __vector_1 (void) { pulseCount++; }

// --- UART, I2C E LCD (Funções condensadas) ---
void uart_init() { REG16(0xC4) = 103; _UCSR0B = (1 << 3) | (1 << 4); _UCSR0C = (3 << 1); }
void uart_putc(char c) { while (!(_UCSR0A & (1 << 5))); _UDR0 = c; }
void uart_puts(const char* s) { while (*s) uart_putc(*s++); }

void i2c_init() { _TWBR = 72; _TWSR = 0x00; }
void i2c_write(unsigned char data) {
    _TWDR = data; _TWCR = (1 << 7) | (1 << 2);
    while (!(_TWCR & (1 << 7)));
}
void lcd_cmd(unsigned char val, unsigned char rs) {
    auto pulse = [&](unsigned char d){
        _TWCR = (1 << 7) | (1 << 5) | (1 << 2); while(!(_TWCR & (1 << 7)));
        _TWDR = (0x27 << 1); _TWCR = (1 << 7) | (1 << 2); while(!(_TWCR & (1 << 7)));
        i2c_write(d | 0x08 | 0x04 | rs); delay_us(1);
        i2c_write((d | 0x08 | rs) & ~0x04); delay_us(50);
        _TWCR = (1 << 7) | (1 << 4) | (1 << 2);
    };
    pulse(val & 0xF0); pulse((val << 4) & 0xF0);
}

// Conversores manuais de texto (Baremetal)
void itoa_manual(int n, char* s) {
    int i = 0, sign = n; if (n < 0) n = -n;
    do { s[i++] = n % 10 + '0'; } while ((n /= 10) > 0);
    if (sign < 0) s[i++] = '-'; s[i] = '\0';
    for (int j = 0, k = i - 1; j < k; j++, k--) { char t = s[j]; s[j] = s[k]; s[k] = t; }
}

void print_f_lcd(float v) {
    char b[10]; int ip = (int)v, dp = (int)((v - ip) * 100);
    if (dp < 0) dp = -dp; itoa_manual(ip, b); while(*b) lcd_cmd(*b++, 1);
    lcd_cmd('.', 1); if (dp < 10) lcd_cmd('0', 1);
    itoa_manual(dp, b); while(*b) lcd_cmd(*b++, 1);
}

void atualiza_interface() {
    lcd_cmd(0x80, 0); while(*"V:") lcd_cmd(*"V:"++, 1); print_f_lcd(vazao_atual);
    lcd_cmd(0xC0, 0); 
    if (param_sel == 0) { while(*"Kp:") lcd_cmd(*"Kp:"++, 1); print_f_lcd(Kp); }
    else if (param_sel == 1) { while(*"Ki:") lcd_cmd(*"Ki:"++, 1); print_f_lcd(Ki); }
    else { while(*"Kd:") lcd_cmd(*"Kd:"++, 1); print_f_lcd(Kd); }
}

// --- ATUAÇÃO ---

void burst_servo(int dir) {
    _OCR1A = (dir == 1) ? SERVO_DIR : SERVO_ESQ;
    delay_ms(25); // Tempo de burst
    _OCR1A = SERVO_STOP;
}

unsigned int sonar() {
    _PORTD |= (1 << 7); delay_us(10); _PORTD &= ~(1 << 7);
    while(!(_PIND & (1 << 6)));
    unsigned int t = 0; while((_PIND & (1 << 6)) && (t < 15000)) { t++; delay_us(1); }
    return t;
}

// --- MAIN ---

int main(void) {
    _DDRB |= (1 << 1) | (1 << 5); _PORTB |= (1 << 5); // Pino 9 e 13 (Bomba PNP)
    _DDRD |= (1 << 7); // Trigger
    _DDRD &= ~((1 << 2)|(1 << 3)|(1 << 4)|(1 << 5)|(1 << 6));
    _PORTD |= (1 << 2)|(1 << 3)|(1 << 4)|(1 << 5); // Pull-ups

    _TCCR1A = (1 << 7) | (1 << 1); _TCCR1B = (1 << 4) | (1 << 3) | (1 << 1); 
    _ICR1 = 40000; _OCR1A = SERVO_STOP; // Servo Timer1

    _EICRA = (1 << 1) | (1 << 0); _EIMSK = (1 << 0); // INT0 (Vazão)
    uart_init(); i2c_init(); // LCD init omitido aqui por brevidade
    _SREG |= (1 << 7); 

    unsigned char l_clk = (_PIND & (1 << 3));
    unsigned char l_sw = (_PIND & (1 << 5));
    unsigned long timer = 0;

    while(1) {
        timer++;
        
        // Encoder (Prioridade)
        unsigned char clk = (_PIND & (1 << 3));
        if (clk != l_clk && clk == 0) {
            if ((_PIND & (1 << 4)) != clk) {
                if (param_sel == 0) Kp += 0.1; else if (param_sel == 1) Ki += 0.01; else Kd += 0.01;
            } else {
                if (param_sel == 0) Kp -= 0.1; else if (param_sel == 1) Ki -= 0.01; else Kd -= 0.01;
            }
            atualiza_interface();
        }
        l_clk = clk;

        // Botão Encoder
        unsigned char sw = (_PIND & (1 << 5));
        if (!sw && l_sw) { delay_ms(20); param_sel = (param_sel + 1) % 3; atualiza_interface(); }
        l_sw = sw;

        // Bomba e PID (~1 seg)
        if (timer > 20000) {
            unsigned int d = sonar();
            if (d > 900) { c_on++; c_off=0; if(c_on>=5){ _PORTB &= ~(1 << 5); c_on=0; } }
            else if (d < 600) { c_off++; c_on=0; if(c_off>=5){ _PORTB |= (1 << 5); c_off=0; } }

            _SREG &= ~(1 << 7); vazao_atual = (float)pulseCount / 7.5; pulseCount = 0; _SREG |= (1 << 7);
            erro = setpoint - vazao_atual;
            integral += erro; if(integral > 25) integral = 25;
            float out = (Kp * erro) + (Ki * integral) + (Kd * (erro - erro_anterior));
            erro_anterior = erro;

            if (out > 1.2) burst_servo(1); else if (out < -1.2) burst_servo(-1);
            atualiza_interface();
            timer = 0;
        }
    }
}
